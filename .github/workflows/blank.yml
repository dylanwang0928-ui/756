<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>扭擺運動演示 (Torsional Pendulum)</title>
  <style>
    body {
      margin: 0;
      background: #f0f8ff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 1px solid #ccc;
      background: #eef;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

    const engine = Engine.create();
    const world = engine.world;

    // 建立畫布
    const render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        width: 600,
        height: 400,
        wireframes: false,
        background: '#f0f8ff'
      }
    });
    Render.run(render);

    const runner = Runner.create();
    Runner.run(runner, engine);

    // 扭擺棒
    const pendulum = Bodies.rectangle(300, 200, 20, 200, {
      inertia: Infinity,   // 防止自動計算慣性矩 (我們自己控制)
      frictionAir: 0.01,   // 空氣阻力 (阻尼)
      render: { fillStyle: '#444' }
    });

    Composite.add(world, pendulum);

    // 固定位置 (扭擺的懸吊點)
    const pivot = { x: 300, y: 100 };

    // 扭力常數 k (越大越「硬」)
    const k = 0.002;

    // 在每次更新前施加扭力
    Events.on(engine, 'beforeUpdate', function() {
      // 計算相對角度 (以豎直向下為 0)
      const angle = pendulum.angle;

      // 恢復力矩 τ = -kθ
      const torque = -k * angle;

      // 套用力矩 = 力 * 力臂長
      Body.setAngularVelocity(pendulum, pendulum.angularVelocity + torque);
    });

    // 初始旋轉 (推一把)
    Body.setAngle(pendulum, Math.PI / 4); // 初始 45 度
    Body.setAngularVelocity(pendulum, -0.2);
  </script>
</body>
</html>
